package xml.booking.managers;

import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.List;
import java.util.function.Function;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageImpl;
import org.springframework.data.domain.Pageable;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Component;

import xml.booking.dto.AccommodationUnitDTO;
import xml.booking.dto.CodeBookDTO;
import xml.booking.dto.SearchDTO;
import xml.booking.feign.AccommodationUnitProxy;
import xml.booking.model.Accommodation;
import xml.booking.model.AccommodationCategory;
import xml.booking.model.AccommodationType;
import xml.booking.model.AccommodationUnit;
import xml.booking.model.AdditionalService;
import xml.booking.repositories.AccommodationCategoryRepository;
import xml.booking.repositories.AccommodationRepository;
import xml.booking.repositories.AccommodationTypeRepository;
import xml.booking.repositories.AccommodationUnitRepository;

/**
* Generated by Spring Data Generator on 18/05/2019
*/
@Component
public class AccommodationUnitManager {

	@Autowired
	private AccommodationUnitRepository accommodationUnitRepository;
	
	@Autowired
	private AccommodationTypeRepository accommodationTypeRepository;
	
	@Autowired
	private AccommodationCategoryRepository accommodationCategoryRepository;
	
	@Autowired
	private AccommodationRepository accommodationRepository;
	
	@Autowired
	private AccommodationUnitProxy accommodationUnitProxy;

	/**
	 * Normalna pretraga - ukljucuje lokaciju, datum dolaska, datum odlaska i broj osoba
	 */
	public Page<AccommodationUnitDTO> regularSearch(String location, Long beginningDate, Long endDate, Integer numberOfPersons, Pageable page) {
		
		Page<AccommodationUnit> units = accommodationUnitRepository.regularSearch(page, location, numberOfPersons, beginningDate, endDate, false);
		
		return mapPageToDTO(units, beginningDate, endDate);		
	}
	
	/**
	 * Napredna pretraga - osim lokacija, datuma dolaska i odlaska i broja osoba,
	 * ukljucuje i tip smestaja, kategoriju smestaja, dodatne usluge i udaljenost od trenutne lokacije korisnika
	 * 
	 */
	public Page<AccommodationUnitDTO> advancedSearch(SearchDTO searchObject, Pageable page) {
		
		List<AdditionalService> services = null;
		if(searchObject.getAdditionalServices() != null && !searchObject.getAdditionalServices().isEmpty()) {
			services = new ArrayList<AdditionalService>();
			for(CodeBookDTO dto : searchObject.getAdditionalServices()) {
				services.add(new AdditionalService(dto));
			}
		}
		
		List<AccommodationUnit> units = accommodationUnitRepository.advancedSearch(searchObject.getLocation(), searchObject.getNumberOfPersons(), 
                							searchObject.getBeginningDate(), searchObject.getEndDate(), false, searchObject.getAccommodationType(),
                							searchObject.getAccommodationCategory(), services);

		List<AccommodationUnitDTO> dtos = mapListToDTO(units, searchObject.getBeginningDate(), searchObject.getEndDate(), searchObject.getDistance(), searchObject.getUserLongitude(), searchObject.getUserLatitude());		
		
		return new PageImpl<AccommodationUnitDTO>(dtos, page, dtos.size());
	}
	
	/**
	 * Pronalazenje cene smestaja u zadatom vremenskom intervalu; koristi se accommodation-service
	 */
	private Double getAccommodationUnitPrice(Long id, Long beginningDate, Long endDate) {
		ResponseEntity<BigDecimal> response = accommodationUnitProxy.findAccommodationPrice(beginningDate, endDate, id);
				
		return response.getBody().doubleValue();
	}
		
	private Page<AccommodationUnitDTO> mapPageToDTO(Page<AccommodationUnit> accommodationUnits, Long beginningDate, Long endDate){
		
		Page<AccommodationUnitDTO> dtos = accommodationUnits.map(new Function<AccommodationUnit, AccommodationUnitDTO>() {
		    @Override
		    public AccommodationUnitDTO apply(AccommodationUnit accommodationUnit) {		    	
		    	
		    	Accommodation accommodation = accommodationRepository.findAccommodationByAccommodationUnitId(accommodationUnit.getId());		    	
		    	AccommodationCategory category = accommodationCategoryRepository.findCategoryByAccommodationUnitId(accommodationUnit.getId());		    	
		    	AccommodationType type = accommodationTypeRepository.findTypeByAccommodationUnitId(accommodationUnit.getId());
		    	
		    	Double price = getAccommodationUnitPrice(accommodationUnit.getId(), beginningDate, endDate);
		    			    	
		    	AccommodationUnitDTO accommodationUnitDTO = new AccommodationUnitDTO(accommodationUnit, price, accommodation.getName(), category.getName(),
		    														type.getName(), accommodation.getDescription(), accommodation.getId());
		    	
		   		return accommodationUnitDTO;
		    }
		});
		
		return dtos;		
	}
	
	private List<AccommodationUnitDTO> mapListToDTO(List<AccommodationUnit> accommodationUnits, Long beginningDate, Long endDate, Double distance, Double longitude, Double latitude){
		
		List<AccommodationUnitDTO> dtoList = new ArrayList<AccommodationUnitDTO>();
		
		for(AccommodationUnit au : accommodationUnits) {
			
	    	 Accommodation accommodation = accommodationRepository.findAccommodationByAccommodationUnitId(au.getId());		    	

			
				if(distance != null && (distance(accommodation.getLocation().getLatitude().doubleValue(), latitude, accommodation.getLocation().getLongitude().doubleValue(), longitude) > distance)) {
					continue;
				}
		    	
		    	AccommodationCategory category = accommodationCategoryRepository.findCategoryByAccommodationUnitId(au.getId());		    	
		    	AccommodationType type = accommodationTypeRepository.findTypeByAccommodationUnitId(au.getId());
		    	
		    	Double price = getAccommodationUnitPrice(au.getId(), beginningDate, endDate);
		    			    	
		    	AccommodationUnitDTO accommodationUnitDTO = new AccommodationUnitDTO(au, price, accommodation.getName(), category.getName(),
		    													type.getName(), accommodation.getDescription(), accommodation.getId());
		    	
		    	dtoList.add(accommodationUnitDTO);
		}
		
		return dtoList;		

	}
	
	private double distance(double lat1, double lat2, double lon1, double lon2) {
	    final int R = 6371; // Radius of the earth
	    double latDistance = Math.toRadians(lat2 - lat1);
	    double lonDistance = Math.toRadians(lon2 - lon1);
	    double a = Math.sin(latDistance / 2) * Math.sin(latDistance / 2) + Math.cos(Math.toRadians(lat1))
	        * Math.cos(Math.toRadians(lat2)) * Math.sin(lonDistance / 2) * Math.sin(lonDistance / 2);
	    double c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
	    double distance = R * c; // in kilometers
	    distance = Math.sqrt(Math.pow(distance, 2));
	    return distance;
	  }
}
